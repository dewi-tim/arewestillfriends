<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="utf-8" />
    <title>ARE WE STILL FRIENDS - pride street party</title>
    <meta name="viewport" content="width=device-width,initial-scale=1" />

    <!-- Bodoni Moda bold -->
    <link rel="preconnect" href="https://fonts.googleapis.com" />
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
    <link href="https://fonts.googleapis.com/css2?family=Bodoni+Moda:wght@700&display=swap" rel="stylesheet" />

    <link rel="icon" type="image/png" href="favicon.png" />

    <style>
        @font-face {
            font-family: "Concrette";
            src: url("ConcretteSTRIAL-LightItalic.woff2") format("woff2");
        }

        html {
            height: 100%;
        }
        
        body {
            user-select: none;
            margin: 0;
            background: #fff;
            color: #000;
            font-family: "Bodoni Moda", serif;
            font-weight: 700;
            font-style: italic;
            min-height: 100%;
            overflow-y: auto;
            overflow-x: hidden;
        }

        canvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            z-index: 0;
            image-rendering: pixelated;
            pointer-events: auto; /* Allow clicks for links */
        }

        /* overlay holds everything and keeps it centered */
        #overlay {
            position: relative;
            z-index: 1;
            min-height: 100vh;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            gap: 3rem;
            padding: 4vh 1rem;
            box-sizing: border-box;
        }

        /* logo scales fluidly */
        .logo {
            text-align: center;
        }
        
        .logo h1 {
            font-size: clamp(2rem, 8vw, 5rem);
            font-weight: 700;
            font-style: italic;
            margin: 0;
            line-height: 1;
            color: #000;
        }
        
        .logo h2 {
            font-size: clamp(1.5rem, 6vw, 3.5rem);
            font-weight: 700;
            font-style: italic;
            margin: 0.5rem 0 0 0;
            color: #000;
        }

        /* event info */
        .event-info {
            text-align: left;
            width: 100%;
            max-width: 768px;
            padding: 3rem;
            background: rgba(255, 255, 255, 0.7);
            backdrop-filter: blur(20px);
            -webkit-backdrop-filter: blur(20px);
            border: 1px solid rgba(255, 255, 255, 0.3);
            box-shadow: 0 8px 32px 0 rgba(31, 38, 135, 0.37);
            box-sizing: border-box;
            font-family: "Bodoni Moda", serif;
            font-weight: 700;
            text-transform: lowercase;
        }
        
        .event-info p {
            font-size: clamp(1.2rem, 3vw, 1.5rem);
            margin: 1rem 0;
            font-style: normal;
            color: #000;
            line-height: 1.4;
        }
        
        .event-info .locations {
            display: flex;
            gap: 2rem;
            justify-content: center;
            flex-wrap: wrap;
            margin: 1.5rem 0;
        }
        
        .event-info .location {
            flex: 1;
            min-width: 200px;
        }
        
        .event-info h3 {
            font-size: 1.6rem;
            margin: 1.5rem 0 1rem 0;
            color: #000;
            font-weight: 700;
            text-transform: lowercase;
        }
        
        .event-info .location p {
            color: #666;
            font-weight: 600;
            font-style: normal;
        }
        
        .event-info .donate-section {
            margin-top: 2rem;
            padding-top: 1.5rem;
            border-top: 1px solid rgba(0, 0, 0, 0.2);
        }
        
        .event-info .donate-section p {
            font-size: 1rem;
            margin-bottom: 1rem;
            color: #333;
            font-style: normal;
        }
        
        .event-info .social-links {
            display: flex;
            gap: 1.5rem;
            justify-content: center;
            flex-wrap: wrap;
            margin-top: 1rem;
        }
        
        .event-info .social-links a {
            color: #000;
            text-decoration: none;
            font-weight: 700;
            font-size: 1.1rem;
            transition: all 0.2s;
            padding: 0.3rem 0.8rem;
            background: rgba(0, 0, 0, 0.05);
        }
        
        .event-info .social-links a:hover {
            transform: scale(1.05);
            background: rgba(0, 0, 0, 0.1);
        }

        @media (max-width: 600px) {
            .event-info {
                padding: 1rem;
            }
            
            .event-info .locations {
                flex-direction: column;
                gap: 1rem;
            }
        }
    </style>
</head>

<body>
    <canvas id="c"></canvas>

    <div id="overlay" style="display: none;">
    </div>

    <script>
        /* ───── tweakables ───── */
        const BRIGHTNESS_RATE = 12.0;
        const VARIANT_RATE = 6.3;
        const GAMMA_CURVE = 1.0;
        const SPECK_DENSITY = 0.04;
        const SPECK_SEED = [314.15, 271.82];
        /* ────────────────────── */

        /* tiny 5×7 font */
        const font5x7 = [
            {
                letter: "A",
                code: [" ### ", "#   #", "#   #", "#   #", "#####", "#   #", "#   #"],
            },
            {
                letter: "B",
                code: ["#### ", "#   #", "#   #", "#### ", "#   #", "#   #", "#### "],
            },
            {
                letter: "C",
                code: [" ####", "#    ", "#    ", "#    ", "#    ", "#    ", " ####"],
            },
            {
                letter: "D",
                code: ["#### ", "#   #", "#   #", "#   #", "#   #", "#   #", "#### "],
            },
            {
                letter: "E",
                code: ["#####", "#    ", "#    ", "#####", "#    ", "#    ", "#####"],
            },
            {
                letter: "F",
                code: ["#####", "#    ", "#    ", "#####", "#    ", "#    ", "#    "],
            },
            {
                letter: "G",
                code: [" ####", "#    ", "#    ", "#  ##", "#   #", "#   #", " ####"],
            },
            {
                letter: "H",
                code: ["#   #", "#   #", "#   #", "#####", "#   #", "#   #", "#   #"],
            },
            {
                letter: "I",
                code: ["  #  ", "  #  ", "  #  ", "  #  ", "  #  ", "  #  ", "  #  "],
            },
            {
                letter: "J",
                code: ["    #", "    #", "    #", "    #", "    #", "    #", "#### "],
            },
            {
                letter: "K",
                code: ["#   #", "#  # ", "# #  ", "##   ", "# #  ", "#  # ", "#   #"],
            },
            {
                letter: "L",
                code: ["#    ", "#    ", "#    ", "#    ", "#    ", "#    ", "#####"],
            },
            {
                letter: "M",
                code: ["#   #", "## ##", "# # #", "#   #", "#   #", "#   #", "#   #"],
            },
            {
                letter: "N",
                code: ["#   #", "##  #", "# # #", "#  ##", "#   #", "#   #", "#   #"],
            },
            {
                letter: "O",
                code: [" ### ", "#   #", "#   #", "#   #", "#   #", "#   #", " ### "],
            },
            {
                letter: "P",
                code: ["#### ", "#   #", "#   #", "#### ", "#    ", "#    ", "#    "],
            },
            {
                letter: "Q",
                code: [" ### ", "#   #", "#   #", "#   #", "#   #", "#  ##", " ####"],
            },
            {
                letter: "R",
                code: ["#### ", "#   #", "#   #", "#   #", "#### ", "#   #", "#   #"],
            },
            {
                letter: "S",
                code: [" ####", "#    ", "#    ", " ### ", "    #", "    #", "#### "],
            },
            {
                letter: "T",
                code: ["#####", "  #  ", "  #  ", "  #  ", "  #  ", "  #  ", "  #  "],
            },
            {
                letter: "U",
                code: ["#   #", "#   #", "#   #", "#   #", "#   #", "#   #", " ### "],
            },
            {
                letter: "V",
                code: ["#   #", "#   #", "#   #", "#   #", "#   #", " # # ", "  #  "],
            },
            {
                letter: "W",
                code: ["#   #", "#   #", "#   #", "#   #", "# # #", "## ##", "#   #"],
            },
            {
                letter: "X",
                code: ["#   #", "#   #", " # # ", "  #  ", " # # ", "#   #", "#   #"],
            },
            {
                letter: "Y",
                code: ["#   #", "#   #", "#   #", " ### ", "  #  ", "  #  ", "  #  "],
            },
            {
                letter: "Z",
                code: ["#####", "    #", "   # ", "  #  ", " #   ", "#    ", "#####"],
            },
            {
                letter: "a",
                code: ["     ", "     ", " ### ", "    #", " ####", "#   #", " ####"],
            },
            {
                letter: "b",
                code: ["#    ", "#    ", "#### ", "#   #", "#   #", "#   #", "#### "],
            },
            {
                letter: "c",
                code: ["     ", "     ", " ### ", "#   #", "#    ", "#   #", " ### "],
            },
            {
                letter: "d",
                code: ["    #", "    #", " ####", "#   #", "#   #", "#   #", " ####"],
            },
            {
                letter: "e",
                code: ["     ", "     ", " ### ", "#   #", "#####", "#    ", " ####"],
            },
            {
                letter: "f",
                code: ["  ## ", " #  #", " #   ", "###  ", " #   ", " #   ", " #   "],
            },
            {
                letter: "g",
                code: ["     ", " ####", "#   #", "#   #", " ####", "    #", "#### "],
            },
            {
                letter: "h",
                code: ["#    ", "#    ", "#### ", "#   #", "#   #", "#   #", "#   #"],
            },
            {
                letter: "i",
                code: ["#    ", "     ", "#    ", "#    ", "#    ", "#    ", "#    "],
            },
            {
                letter: "j",
                code: ["    #", "     ", "   ##", "    #", "    #", "#   #", " ### "],
            },
            {
                letter: "k",
                code: ["#    ", "#    ", "#   #", "#  # ", "###  ", "#  # ", "#   #"],
            },
            {
                letter: "l",
                code: ["#    ", "#    ", "#    ", "#    ", "#    ", "#    ", "##   "],
            },
            {
                letter: "m",
                code: ["     ", "     ", "#### ", "# # #", "# # #", "# # #", "# # #"],
            },
            {
                letter: "n",
                code: ["     ", "     ", "#### ", "#   #", "#   #", "#   #", "#   #"],
            },
            {
                letter: "o",
                code: ["     ", "     ", " ### ", "#   #", "#   #", "#   #", " ### "],
            },
            {
                letter: "p",
                code: ["     ", " ### ", " #  #", " #  #", " ### ", " #   ", " #   "],
            },
            {
                letter: "q",
                code: ["     ", "     ", "  ###", " #  #", "  ###", "    #", "    #"],
            },
            {
                letter: "r",
                code: ["     ", "     ", "# ###", "##   ", "#    ", "#    ", "#    "],
            },
            {
                letter: "s",
                code: ["     ", "     ", " ####", "#    ", " ### ", "    #", "#### "],
            },
            {
                letter: "t",
                code: [" #   ", " #   ", "###  ", " #   ", " #   ", " #   ", "  ## "],
            },
            {
                letter: "u",
                code: ["     ", "     ", "#   #", "#   #", "#   #", "#   #", " ### "],
            },
            {
                letter: "v",
                code: ["     ", "     ", "#   #", "#   #", "#   #", " # # ", "  #  "],
            },
            {
                letter: "w",
                code: ["     ", "     ", "#   #", "#   #", "# # #", "# # #", " # # "],
            },
            {
                letter: "x",
                code: ["     ", "     ", "#   #", " # # ", "  #  ", " # # ", "#   #"],
            },
            {
                letter: "y",
                code: ["     ", "     ", "#   #", "#   #", " ####", "    #", "#### "],
            },
            {
                letter: "z",
                code: ["     ", "     ", "#####", "   # ", "  #  ", " #   ", "#####"],
            },
            {
                letter: "0",
                code: [" ### ", "#   #", "#  ##", "# # #", "##  #", "#   #", " ### "],
            },
            {
                letter: "1",
                code: ["##   ", " #   ", " #   ", " #   ", " #   ", " #   ", " #   "],
            },
            {
                letter: "2",
                code: [" ### ", "#   #", "    #", "  ## ", " #   ", "#    ", "#####"],
            },
            {
                letter: "3",
                code: ["#### ", "    #", "    #", " ### ", "    #", "    #", "#### "],
            },
            {
                letter: "4",
                code: ["#   #", "#   #", "#   #", "#####", "    #", "    #", "    #"],
            },
            {
                letter: "5",
                code: ["#####", "#    ", "#    ", "#### ", "    #", "    #", "#### "],
            },
            {
                letter: "6",
                code: [" ####", "#    ", "#    ", " ### ", "#   #", "#   #", " ### "],
            },
            {
                letter: "7",
                code: ["#####", "    #", "    #", "  ## ", " #   ", " #   ", " #   "],
            },
            {
                letter: "8",
                code: [" ### ", "#   #", "#   #", " ### ", "#   #", "#   #", " ### "],
            },
            {
                letter: "9",
                code: [" ### ", "#   #", "#   #", " ####", "    #", "    #", " ### "],
            },
            {
                letter: "!",
                code: ["#    ", "#    ", "#    ", "#    ", "#    ", "     ", "#    "],
            },

            {
                letter: ",",
                code: ["     ", "     ", "     ", "     ", "     ", "  #  ", " #   "],
            },
            {
                letter: "?",
                code: [" ##  ", "#  # ", "   # ", "  #  ", " #   ", "     ", " #   "],
            },
            {
                letter: "\x01",
                code: ["     ", " # # ", " # # ", "     ", "  #  ", "#   #", " ### "],
            },
            {
                letter: "%",
                code: ["    #", " #  #", "   # ", "  #  ", " #   ", "#  # ", "#    "],
            },
            {
                letter: "#",
                code: [" # # ", " # # ", "#####", " # # ", "#####", " # # ", " # # "],
            },
            {
                letter: "_",
                code: ["     ", "     ", "     ", "     ", "     ", "     ", "#####"],
            },
            {
                letter: "-",
                code: ["     ", "     ", "     ", " ### ", "     ", "     ", "     "],
            },
            {
                letter: ";",
                code: ["     ", " #   ", "     ", " #   ", " #   ", "#    ", "     "],
            },
            {
                letter: "`",
                code: [" #   ", " #   ", "     ", "     ", "     ", "     ", "     "],
            },
            {
                letter: "=",
                code: ["     ", "#####", "     ", "     ", "#####", "     ", "     "],
            },
            {
                letter: "_",
                code: ["     ", "     ", "     ", "     ", "     ", "     ", "#####"],
            },
            {
                letter: ":",
                code: ["     ", " #   ", "     ", "     ", " #   ", "     ", "     "],
            },
            {
                letter: "<",
                code: ["   # ", "  #  ", " #   ", "#    ", " #   ", "  #  ", "   # "],
            },
            {
                letter: ">",
                code: [" #   ", "  #  ", "   # ", "    #", "   # ", "  #  ", " #   "],
            },
            {
                letter: "~",
                code: ["     ", "     ", "# # #", " # # ", "     ", "     ", "     "],
            },
            {
                letter: "*",
                code: ["  #  ", " ### ", "  #  ", " # # ", "     ", "     ", "     "],
            },
            {
                letter: "/",
                code: ["    #", "    #", "   # ", "  #  ", " #   ", " #   ", "#    "],
            },
            {
                letter: '"',
                code: ["# #  ", "# #  ", "# #  ", "     ", "     ", "     ", "     "],
            },
            {
                letter: "(",
                code: ["  #  ", " #   ", "#    ", "#    ", "#    ", " #   ", "  #  "],
            },
            {
                letter: ")",
                code: ["#    ", " #   ", "  #  ", "  #  ", "  #  ", " #   ", "#    "],
            },
            {
                letter: "}",
                code: ["#    ", " #   ", " #   ", "  #  ", " #   ", " #   ", "#    "],
            },
            {
                letter: "{",
                code: ["  #  ", " #   ", " #   ", "#    ", " #   ", " #   ", "  #  "],
            },
            {
                letter: "+",
                code: ["     ", "     ", "  #  ", "  #  ", "#####", "  #  ", "  #  "],
            },
            {
                letter: "-",
                code: ["     ", "     ", "     ", "     ", "#####", "     ", "     "],
            },
            {
                letter: "[",
                code: [" ### ", " #   ", " #   ", " #   ", " #   ", " #   ", " ### "],
            },
            {
                letter: "]",
                code: [" ### ", "   # ", "   # ", "   # ", "   # ", "   # ", " ### "],
            },
        ];

        /* build glyph atlas (unchanged) */
        const groups = {},
            CELL = { w: 5, h: 7 };
        font5x7.forEach((g) => {
            const pop = g.code.reduce(
                (s, r) => s + [...r].filter((c) => "#" === c).length,
                0,
            );
            (groups[pop] ??= []).push(g);
        });
        Object.keys(groups).forEach((k) => {
            if (groups[k].length === 1) groups[k].push(groups[k][0]);
        });
        const levels = Object.keys(groups)
            .map(Number)
            .sort((a, b) => a - b),
            offs = [],
            lens = [],
            atlasList = [];
        levels.forEach((pop) => {
            offs[pop] = atlasList.length;
            atlasList.push(...groups[pop]);
            lens[pop] = groups[pop].length;
        });
        const MAXB = levels.at(-1),
            N = atlasList.length,
            COLS = Math.ceil(Math.sqrt(N)),
            ROWS = Math.ceil(N / COLS),
            atlasW = COLS * CELL.w,
            atlasH = ROWS * CELL.h,
            atlas = new Uint8Array(atlasW * atlasH);
        atlasList.forEach((g, i) => {
            const cx = i % COLS,
                ry = (i / COLS) | 0;
            g.code.forEach((row, y) =>
                [...row].forEach((ch, x) => {
                    atlas[(ry * CELL.h + y) * atlasW + cx * CELL.w + x] =
                        ch == "#" ? 255 : 0;
                }),
            );
        });

        /* Text content to render with styling markers */
        const textContent = `[ARE WE STILL FRIENDS]

*PRIDE STREET PARTY*

Hey you made it! We are a self-funded startup party DJing and performing *live techno* for Amsterdam pride on *2nd August*

[SCHEDULE]

{PRINSENGRACHT} (parade)

10:00-13:00 f/8abt vinyl  

{NIEUWENDIJK} (street)

14:30-15:30 f/8abt  (live)
15:30-17:00 martini (live)
17:00-end   dewi    (live)

[LINKS]
Support us on {TIKKIE}
Follow us on {INSTAGRAM}`;
        
        // Link URLs
        const links = {
            'TIKKIE': 'https://tikkie.me/pay/u53n0oi82pdd9a3eoll6',
            'INSTAGRAM': 'https://www.instagram.com/arewestillfriends.live/',
            'PRINSENGRACHT': 'https://maps.app.goo.gl/MidrbMGJzNmrJGGy7',
            'NIEUWENDIJK': 'https://maps.app.goo.gl/vm8shJZn8MaGgVk87'
        };
        
        function wrapText(text, maxWidth) {
            const words = text.split(' ');
            const lines = [];
            let currentLine = '';
            
            for (const word of words) {
                const testLine = currentLine ? currentLine + ' ' + word : word;
                if (testLine.length <= maxWidth) {
                    currentLine = testLine;
                } else {
                    if (currentLine) lines.push(currentLine);
                    currentLine = word;
                }
            }
            if (currentLine) lines.push(currentLine);
            return lines;
        }
        
        // Store clickable areas
        const clickableAreas = [];
        
        function parseStyledText(text) {
            // Parse text with style markers * for highlights and {} for links (keeping brackets visible)
            const segments = [];
            let current = '';
            let i = 0;
            
            while (i < text.length) {
                if (text[i] === '*' && i + 1 < text.length) {
                    // Check if this starts a highlight
                    if (current) segments.push({ text: current, style: 'normal' });
                    current = '';
                    i++; // Skip the *
                    let highlightStart = i;
                    while (i < text.length && text[i] !== '*') {
                        current += text[i++];
                    }
                    if (text[i] === '*' && current.length > 0) {
                        // Valid highlight
                        segments.push({ text: current, style: 'highlight' });
                        current = '';
                        i++; // Skip the closing *
                    } else {
                        // Not a valid highlight, treat as normal text
                        current = '*' + current;
                        segments.push({ text: current, style: 'normal' });
                        current = '';
                    }
                } else if (text[i] === '[') {
                    if (current) segments.push({ text: current, style: 'normal' });
                    current = '['; // Keep the opening bracket
                    i++;
                    let bracketContent = '';
                    while (i < text.length && text[i] !== ']') {
                        bracketContent += text[i++];
                    }
                    if (text[i] === ']') {
                        current += bracketContent + ']'; // Keep the closing bracket
                        segments.push({ text: current, style: 'background' });
                        current = '';
                        i++;
                    }
                } else if (text[i] === '{') {
                    if (current) segments.push({ text: current, style: 'normal' });
                    current = '{'; // Keep the opening brace
                    i++;
                    let linkContent = '';
                    while (i < text.length && text[i] !== '}') {
                        linkContent += text[i++];
                    }
                    if (text[i] === '}') {
                        current += linkContent + '}'; // Keep the closing brace
                        segments.push({ text: current, style: 'link', linkText: linkContent.trim() });
                        current = '';
                        i++;
                    }
                } else {
                    current += text[i++];
                }
            }
            if (current) segments.push({ text: current, style: 'normal' });
            return segments;
        }
        
        function layoutText(content, cols, rows) {
            const paragraphs = content.split('\n\n');
            const allLines = [];
            const lineStyles = [];
            const maxLineWidth = Math.min(60, cols - 4); // Leave margin on sides
            
            for (const paragraph of paragraphs) {
                const lines = paragraph.split('\n');
                for (const line of lines) {
                    if (line.trim()) {
                        const segments = parseStyledText(line);
                        let currentLine = '';
                        let currentStyles = [];
                        
                        for (const segment of segments) {
                            const words = segment.text.split(' ');
                            for (let w = 0; w < words.length; w++) {
                                const word = words[w];
                                const needSpace = currentLine && w > 0;
                                const testLine = currentLine + (needSpace ? ' ' : '') + word;
                                
                                if (testLine.length <= maxLineWidth) {
                                    if (needSpace) {
                                        currentLine += ' ';
                                        currentStyles.push({ start: currentLine.length - 1, end: currentLine.length, style: 'normal' });
                                    }
                                    const start = currentLine.length;
                                    currentLine += word;
                                    currentStyles.push({ start, end: currentLine.length, style: segment.style, text: segment.linkText || segment.text });
                                } else {
                                    if (currentLine) {
                                        allLines.push(currentLine);
                                        lineStyles.push(currentStyles);
                                    }
                                    currentLine = word;
                                    currentStyles = [{ start: 0, end: word.length, style: segment.style, text: segment.linkText || segment.text }];
                                }
                            }
                        }
                        
                        if (currentLine) {
                            allLines.push(currentLine);
                            lineStyles.push(currentStyles);
                        }
                    } else {
                        allLines.push('');
                        lineStyles.push([]);
                    }
                }
                allLines.push(''); // Empty line between paragraphs
                lineStyles.push([]);
            }
            
            // Remove trailing empty lines
            while (allLines.length > 0 && allLines[allLines.length - 1] === '') {
                allLines.pop();
                lineStyles.pop();
            }
            
            // Center vertically if content fits, otherwise start at top
            const totalHeight = allLines.length;
            const startY = totalHeight < rows - 4 ? Math.max(2, Math.floor((rows - totalHeight) / 2)) : 2;
            
            // Convert to positioned text with styles
            const fixedText = [];
            clickableAreas.length = 0; // Clear previous clickable areas
            
            allLines.forEach((line, index) => {
                if (line) {
                    const startX = Math.floor((cols - line.length) / 2);
                    fixedText.push({ text: line, x: startX, y: startY + index, styles: lineStyles[index] });
                    
                    // Create clickable areas for links
                    lineStyles[index].forEach(style => {
                        if (style.style === 'link' && links[style.text]) {
                            clickableAreas.push({
                                x: startX + style.start,
                                y: startY + index,
                                width: style.end - style.start,
                                height: 1,
                                url: links[style.text],
                                text: style.text
                            });
                        }
                    });
                }
            });
            
            return fixedText;
        }

        // Create character lookup map
        const charMap = {};
        font5x7.forEach(g => {
            charMap[g.letter] = g;
        });

        /* WebGL */
        const gl = document
            .getElementById("c")
            .getContext("webgl2", { alpha: false });
        function sh(src, t) {
            const s = gl.createShader(t);
            gl.shaderSource(s, src);
            gl.compileShader(s);
            if (!gl.getShaderParameter(s, gl.COMPILE_STATUS))
                throw gl.getShaderInfoLog(s);
            return s;
        }
        const vs = `#version 300 es
        layout(location=0) in vec2 p;void main(){gl_Position=vec4(p,0,1);} `;
        const fs = `#version 300 es
        precision mediump float;precision mediump int;
        out vec4 o;
        #define MAXB ${MAXB}
        #define GW ${CELL.w}
        #define GH ${CELL.h}
        uniform sampler2D A;
        uniform sampler2D textTex;
        uniform ivec2 G,AG,CELL;
        uniform int Px;
        uniform float T,brightnessRate,variantRate,gamma,speckDensity;
        uniform vec2  speckSeed;
        uniform int   offs[MAXB+1],lens[MAXB+1];
        const vec3 PINK=vec3(1.0,0.6,0.8);      // Original pastel pink
        const vec3 BLUE=vec3(0.4,0.6,1.0);      // Pastel blue
        const vec3 PURPLE=vec3(0.8,0.5,1.0);    // Pastel purple
        const vec3 YELLOW=vec3(1.0,0.9,0.5);    // Pastel yellow
        const vec3 LIME=vec3(0.6,1.0,0.0);      // Original lime for specks
        float radial(ivec2 c){return length(vec2(c)-vec2(G)*0.5);}
        int   diag  (ivec2 c){return c.x+c.y;}
        int   tri(int k,int n){int m=k%(2*n);return(m<n)?m:(2*n-m);}
        float hash(vec2 p){return fract(sin(dot(p,vec2(127.1,311.7)))*43758.5453);}
        vec3 mixColors(vec3 a,vec3 b,float t){return mix(a,b,smoothstep(0.0,1.0,t));}
        void main(){
          ivec2 frag=ivec2(gl_FragCoord.xy);
          ivec2 gPix=frag/Px;                      // glyph-pixel
          
          // Add virtual spacing between cells
          int cellWidth = GW + 1;  // 5 + 1 pixel border
          int cellHeight = GH + 1; // 7 + 1 pixel border
          
          ivec2 cell=ivec2(gPix.x/cellWidth,(G.y*cellHeight-1-gPix.y)/cellHeight);
          ivec2 locInCell =ivec2(gPix.x%cellWidth,gPix.y%cellHeight);
          
          // Check for fixed text style first
          vec2 texCoord = vec2(float(cell.x)/256.0, float(cell.y)/256.0);
          vec4 textInfo=texture(textTex,texCoord);
          float fixedChar=textInfo.r;
          float styleType=textInfo.g;
          
          // Check if we're in the border area
          if(locInCell.x >= GW || locInCell.y >= GH){
            // Apply appropriate background for border pixels
            if(fixedChar>0.0 && styleType > 0.2 && styleType < 0.3) {
              // Grey background for bracketed text borders
              o=vec4(0.92,0.92,0.92,1.0);
            } else if(fixedChar>0.0) {
              // White background for other fixed text borders
              o=vec4(1.0);
            } else {
              // Regular animated background for empty cells
              o=vec4(1.0);
            }
            return;
          }
          
          ivec2 loc = locInCell; // Use the position within the actual glyph
          
          // Calculate angle from center
          vec2 cellCenter=vec2(cell)+0.5;
          vec2 gridCenter=vec2(G)*0.5;
          vec2 dir=cellCenter-gridCenter;
          // Use atan2 for proper angle calculation (-π to π)
          float angle=atan(dir.y,dir.x);
          // Normalize to 0-1 range, ensuring smooth wrapping
          float angleNorm=(angle+3.14159)/(2.0*3.14159);
          
          // Interpolate between colors based on angle (smooth circular interpolation)
          vec3 colorBase;
          float segment=angleNorm*4.0;
          if(segment<1.0){
            colorBase=mixColors(PINK,BLUE,fract(segment));
          }else if(segment<2.0){
            colorBase=mixColors(BLUE,PURPLE,fract(segment));
          }else if(segment<3.0){
            colorBase=mixColors(PURPLE,YELLOW,fract(segment));
          }else{
            // Ensure smooth transition back to PINK at the boundary
            colorBase=mixColors(YELLOW,PINK,smoothstep(0.0,1.0,fract(segment)));
          }
          
          int stepB=int(floor(T*brightnessRate));
          int bRaw=(stepB+int(radial(cell)))%(MAXB+1);
          float wB=pow(float(bRaw)/float(MAXB),gamma);
          int v=tri(int(floor(T*variantRate))+diag(cell),lens[bRaw]);
          int idx=offs[bRaw]+v;
          // Check for fixed text (already retrieved above)
          if(fixedChar>0.0){
            // Fixed text areas have white background
            if(fixedChar > 0.99) {
              // This is a space (value 255/255 = 1.0)
              o=vec4(1.0,1.0,1.0,1.0); // White background for spaces
              return;
            }
            // Use fixed character
            int fixedIdx=int(fixedChar*255.0)-1;
            int cx2=fixedIdx%AG.x,ry2=fixedIdx/AG.x;
            vec2 base2=(vec2(cx2,ry2)*vec2(CELL)+vec2(loc.x,GH-1-loc.y)+.5)/(vec2(AG)*vec2(CELL));
            float mask2=texture(A,base2).r;
            if(mask2>0.0){
              if(styleType > 0.2 && styleType < 0.3) {
                // Background style - black text on grey background
                o=vec4(0.0,0.0,0.0,1.0); // Black text (background handled separately)
              } else if(styleType > 0.4 && styleType < 0.6) {
                // Highlight style - darker grey text on white background
                o=vec4(0.3,0.3,0.3,1.0); // Darker grey text
              } else if(styleType > 0.9) {
                // Link style - blue text on white background
                o=vec4(0.0,0.0,0.7,1.0); // Blue links
              } else {
                // Normal text - black on white background
                o=vec4(0.0,0.0,0.0,1.0); // Black text
              }
            } else {
              // Background for fixed text areas
              if(styleType > 0.2 && styleType < 0.3) {
                // Lighter grey background for bracketed text
                o=vec4(0.92,0.92,0.92,1.0);
              } else {
                // White background for other fixed text
                o=vec4(1.0,1.0,1.0,1.0);
              }
            }
            return;
          }
          
          int cx=idx%AG.x,ry=idx/AG.x;
          vec2 base=(vec2(cx,ry)*vec2(CELL)+vec2(loc.x,GH-1-loc.y)+.5)/(vec2(AG)*vec2(CELL));
          float mask=texture(A,base).r;
          if(mask==0.0){o=vec4(1.0);return;}
          vec3 col=mix(vec3(1.0),colorBase,wB);
          // Reduce opacity by blending with white
          vec3 fadedCol = mix(vec3(1.0), col, 0.45); // 45% opacity
          o=vec4(fadedCol,1.0);
        }`;
        const prog = gl.createProgram();
        gl.attachShader(prog, sh(vs, gl.VERTEX_SHADER));
        gl.attachShader(prog, sh(fs, gl.FRAGMENT_SHADER));
        gl.linkProgram(prog);
        gl.useProgram(prog);

        const U = {
            A: gl.getUniformLocation(prog, "A"),
            textTex: gl.getUniformLocation(prog, "textTex"),
            G: gl.getUniformLocation(prog, "G"),
            AG: gl.getUniformLocation(prog, "AG"),
            CELL: gl.getUniformLocation(prog, "CELL"),
            Px: gl.getUniformLocation(prog, "Px"),
            T: gl.getUniformLocation(prog, "T"),
            brightnessRate: gl.getUniformLocation(prog, "brightnessRate"),
            variantRate: gl.getUniformLocation(prog, "variantRate"),
            gamma: gl.getUniformLocation(prog, "gamma"),
            speckDensity: gl.getUniformLocation(prog, "speckDensity"),
            speckSeed: gl.getUniformLocation(prog, "speckSeed"),
            offs: gl.getUniformLocation(prog, "offs"),
            lens: gl.getUniformLocation(prog, "lens"),
        };
        gl.uniform1i(U.A, 0);
        gl.uniform1i(U.textTex, 1);
        gl.uniform2iv(U.AG, [COLS, ROWS]);
        gl.uniform2iv(U.CELL, [CELL.w, CELL.h]);
        gl.uniform1f(U.brightnessRate, BRIGHTNESS_RATE);
        gl.uniform1f(U.variantRate, VARIANT_RATE);
        gl.uniform1f(U.gamma, GAMMA_CURVE);
        gl.uniform1f(U.speckDensity, SPECK_DENSITY);
        gl.uniform2f(U.speckSeed, SPECK_SEED[0], SPECK_SEED[1]);
        gl.uniform1iv(U.offs, new Int32Array(offs));
        gl.uniform1iv(U.lens, new Int32Array(lens));

        gl.pixelStorei(gl.UNPACK_ALIGNMENT, 1);
        const tex = gl.createTexture();
        gl.activeTexture(gl.TEXTURE0);
        gl.bindTexture(gl.TEXTURE_2D, tex);
        gl.texImage2D(
            gl.TEXTURE_2D,
            0,
            gl.R8,
            atlasW,
            atlasH,
            0,
            gl.RED,
            gl.UNSIGNED_BYTE,
            atlas,
        );
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);
        
        // Create fixed text texture (RGBA: R=char, G=style)
        const textTex = gl.createTexture();
        const textData = new Uint8Array(256 * 256 * 4); // RGBA format
        
        function updateTextTexture(cols, rows) {
            // Clear texture
            textData.fill(0);
            
            // Layout and render text
            const fixedText = layoutText(textContent, cols, rows);
            fixedText.forEach(({ text, x, y, styles }) => {
                for (let i = 0; i < text.length; i++) {
                    const char = text[i];
                    const cellX = x + i;
                    const cellY = y;
                    
                    if (cellX < cols && cellY < rows) {
                        // Find character in font
                        let charIndex = 0;
                        if (char === ' ') {
                            // Mark spaces as part of fixed text with a special value
                            charIndex = 255; // Special value for spaces
                        } else {
                            for (let j = 0; j < atlasList.length; j++) {
                                if (atlasList[j].letter === char) {
                                    charIndex = j + 1; // +1 to distinguish from 0 (no text)
                                    break;
                                }
                            }
                        }
                        
                        // Find style for this character position
                        let styleValue = 0; // 0 = normal, 64 = background, 128 = highlight, 255 = link
                        if (styles) {
                            for (const style of styles) {
                                if (i >= style.start && i < style.end) {
                                    if (style.style === 'background') styleValue = 64;
                                    else if (style.style === 'highlight') styleValue = 128;
                                    else if (style.style === 'link') styleValue = 255;
                                    break;
                                }
                            }
                        }
                        
                        // Store in texture (RGBA format)
                        const idx = (cellY * 256 + cellX) * 4;
                        textData[idx] = charIndex;     // R channel: character (255 = space)
                        textData[idx + 1] = styleValue; // G channel: style
                        textData[idx + 2] = 0;          // B channel: unused
                        textData[idx + 3] = 255;        // A channel: full alpha
                    }
                }
            });
            
            gl.activeTexture(gl.TEXTURE1);
            gl.bindTexture(gl.TEXTURE_2D, textTex);
            gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, 256, 256, 0, gl.RGBA, gl.UNSIGNED_BYTE, textData);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
        }

        /* quad */
        const vbo = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, vbo);
        gl.bufferData(
            gl.ARRAY_BUFFER,
            new Float32Array([-1, -1, 1, -1, -1, 1, 1, -1, 1, 1, -1, 1]),
            gl.STATIC_DRAW,
        );
        gl.enableVertexAttribArray(0);
        gl.vertexAttribPointer(0, 2, gl.FLOAT, false, 0, 0);

        /* resize */
        function resize() {
            // Fixed pixel size
            const CELL_SIZE_PX = 2;
            
            // Calculate how many cells fit in viewport
            let cols = Math.floor(innerWidth / ((CELL.w + 1) * CELL_SIZE_PX));
            let rows = Math.floor(innerHeight / ((CELL.h + 1) * CELL_SIZE_PX));
            
            // First, count actual content lines to determine needed height
            const testParagraphs = textContent.split('\n\n');
            let estimatedLines = 0;
            
            for (const paragraph of testParagraphs) {
                const lines = paragraph.split('\n');
                for (const line of lines) {
                    if (line.trim()) {
                        // Estimate wrapped lines
                        const wrappedCount = Math.ceil(line.length / (cols - 4));
                        estimatedLines += wrappedCount;
                    }
                }
                estimatedLines += 1; // Empty line between paragraphs
            }
            
            // Calculate rows needed for content plus some margin
            const contentRows = estimatedLines + 4;
            const finalRows = Math.max(rows, contentRows);
            
            // Use calculated pixel size
            let P = CELL_SIZE_PX;
            
            gl.canvas.width = cols * (CELL.w + 1) * P;
            gl.canvas.height = finalRows * (CELL.h + 1) * P;
            gl.viewport(0, 0, gl.canvas.width, gl.canvas.height);
            gl.canvas.style.width = innerWidth + "px";
            gl.canvas.style.height = (finalRows * (CELL.h + 1) * P) + "px";
            
            // Disable scrolling if content fits
            if (finalRows <= rows) {
                document.body.style.overflow = 'hidden';
            } else {
                document.body.style.overflow = 'auto';
            }
            
            gl.uniform2iv(U.G, [cols, finalRows]);
            gl.uniform1i(U.Px, P);
            updateTextTexture(cols, finalRows);
        }
        resize();
        addEventListener("resize", resize);

        /* loop */
        const t0 = performance.now();
        (function loop() {
            gl.uniform1f(U.T, (performance.now() - t0) * 0.001);
            gl.drawArrays(gl.TRIANGLES, 0, 6);
            requestAnimationFrame(loop);
        })();
        
        // Handle clicks on links
        gl.canvas.addEventListener('click', (e) => {
            const rect = gl.canvas.getBoundingClientRect();
            const x = e.clientX - rect.left;
            const y = e.clientY - rect.top;
            
            // Convert to cell coordinates
            const cellX = Math.floor(x / gl.canvas.width * gl.canvas.width / ((CELL.w + 1) * CELL_SIZE_PX));
            const cellY = Math.floor(y / gl.canvas.height * gl.canvas.height / ((CELL.h + 1) * CELL_SIZE_PX));
            
            // Check if click is on a clickable area
            for (const area of clickableAreas) {
                if (cellX >= area.x && cellX < area.x + area.width &&
                    cellY === area.y) {
                    window.open(area.url, '_blank');
                    break;
                }
            }
        });
        
        // Change cursor on hover
        gl.canvas.addEventListener('mousemove', (e) => {
            const rect = gl.canvas.getBoundingClientRect();
            const x = e.clientX - rect.left;
            const y = e.clientY - rect.top;
            
            // Convert to cell coordinates
            const cellX = Math.floor(x / gl.canvas.width * gl.canvas.width / ((CELL.w + 1) * CELL_SIZE_PX));
            const cellY = Math.floor(y / gl.canvas.height * gl.canvas.height / ((CELL.h + 1) * CELL_SIZE_PX));
            
            // Check if hovering over a clickable area
            let isOverLink = false;
            for (const area of clickableAreas) {
                if (cellX >= area.x && cellX < area.x + area.width &&
                    cellY === area.y) {
                    isOverLink = true;
                    break;
                }
            }
            
            gl.canvas.style.cursor = isOverLink ? 'pointer' : 'default';
        });
        
        // Store CELL_SIZE_PX globally for click handlers
        window.CELL_SIZE_PX = 2;
    </script>
</body>

</html>
